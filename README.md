# Rubics-cube-2-2-2

This code defines a Rubik's cube and a set of permutation functions that represent the possible quarter twists that can be made on the cube. The cube is represented using a tuple of length 24, where each element corresponds to a cubie on the cube and is assigned a unique identifier. The permutation functions are defined using tuples that represent the new position of each cubie after the permutation is applied.

The perm_apply function takes a permutation and a position, and returns the new position of each cubie after the permutation is applied. The perm_inverse function takes a permutation and returns its inverse permutation. The perm_to_string function converts a permutation to a string representation. The I variable represents the identity permutation of the cube, where each cubie stays in its original position.

There are six possible quarter twists that can be applied to the cube, represented by the F, Fi, L, Li, U, and Ui permutations. Each of these permutations represents a rotation of the front, left, or upper face of the cube, either clockwise or counter-clockwise. The quarter_twists variable is a tuple that contains these six permutations.

The quarter_twists_names dictionary maps each permutation to a string representation of its name, which is used for labeling the moves during the presentation.

During the presentation, you could explain how the code represents a Rubik's cube and the possible quarter twists that can be made on it. You could also demonstrate how the perm_apply function can be used to apply the quarter twists to the cube and show the resulting positions of the cubies. Additionally, you could show how the quarter_twists_names dictionary can be used to label the quarter twists during the presentation.

The code is an implementation of the shortest path algorithm for solving Rubik's cube. The Rubik's cube can be represented by a permutation of its faces, and the algorithm performs a breadth-first search to find the shortest sequence of moves that can transform the initial permutation into the solved permutation.

The code defines two functions: shortest_path and shortest_path_optimized. The shortest_path function performs a simple breadth-first search to find the shortest path from the initial permutation to the solved permutation. The shortest_path_optimized function is an optimized version of the algorithm that uses a bidirectional search to find the shortest path.

Both functions use the rubik_cube module, which defines the Rubik's cube permutations and moves. The rubik_cube module contains two dictionaries: quarter_twists and quarter_twists_names, which map the quarter-turn moves to their corresponding permutations and names.

The shortest_path function initializes a dictionary visited to keep track of the visited permutations, and a deque queue to store the permutations that need to be visited. The function starts by adding the initial permutation to the visited dictionary and the queue. The function then performs a breadth-first search by iterating over all the quarter-turn moves and applying them to the current permutation. For each new permutation, the function checks if it has already been visited. If the permutation has not been visited, it adds it to the visited dictionary and the queue. The function continues to iterate over the queue until it finds the solved permutation or the queue becomes empty.

If the function finds the solved permutation, it constructs the shortest path from the initial permutation to the solved permutation by backtracking from the solved permutation to the initial permutation using the visited dictionary. If the function does not find the solved permutation, it returns None.

The shortest_path_optimized function is similar to the shortest_path function but uses two queues to perform a bidirectional search. The function initializes two dictionaries to keep track of the parents and the distances of the permutations from the start and the end, and two sets to keep track of the visited permutations from the start and the end. The function starts by adding the initial and the solved permutations to their respective queues, visited sets, and distance dictionaries. The function then performs a bidirectional search by iteratively popping permutations from both queues, applying quarter-turn moves to the permutations, and checking if the new permutations have already been visited. If the new permutation has already been visited, the function checks if the distance to the new permutation is shorter than the current distance. If the new permutation has not been visited, the function adds it to the visited set and the queue and updates its distance and parent. The function continues to iterate over the queues until it finds a permutation that has been visited from both the start and the end. If the function finds such a permutation, it constructs the shortest path from the initial permutation to the solved permutation by backtracking from the found permutation to the initial permutation using the parent dictionaries. If the function does not find such a permutation, it returns None.
